# Лабораторная работа №2
**Выполнил**: Медведев Ярослав 409111
***
## Вариант "RbSet"

## Требования
1. Функции:
 - добавление и удаление элементов;
 - фильтрация;
 - отображение (map);
 - свертки (левая и правая);
 - структура должна быть моноидом.
2. Структуры данных должны быть неизменяемыми.
Библиотека должна быть протестирована в рамках unit testing.
3. Библиотека должна быть протестирована в рамках property-based тестирования (как минимум 3 свойства, включая свойства моноида).
4. Структура должна быть полиморфной.
5. Требуется использовать идиоматичный для технологии стиль программирования. Примечание: некоторые языки позволяют получить большую часть API через реализацию небольшого интерфейса. Так как лабораторная работа про ФП, а не про экосистему языка -- необходимо реализовать их вручную и по возможности -- обеспечить совместимость.
6. Обратите внимание:
 - API должно быть реализовано для заданного интерфейса и оно не должно "протекать". На уровне тестов -- в первую очередь нужно протестировать именно API (dict, set, bag).
 - Должна быть эффективная реализация функции сравнения (не наивное приведение к спискам, их сортировка с последующим сравнением), реализованная на уровне API, а не внутреннего представления.
***
## Ключевые элементы реализации
### Общая струкура
1. RbTree - мапа на красно-черном дереве.
2. Node - вершина в красно-черном дереве.
3. Comparable - протокол, который необходимо реализовать, чтобы объект мог быть ключем мапы/элементом множества.
4. Monoid - протокол, описывающий свойства моноида.
5ю 
### Красно-черное дерево
1. Красно-черное дерево было реализовано в виде мапы (RbTree), на его основе уже было реализовано множество.
2. Алгоритм вставки работает следующим образом: сначала вставляем красный узел, потом происходит балансировка по алгоритму Окасаки. 
3. Удаление происходит следующим образом: перед тем как спускаться в поддерево, стараемся сделать так, чтобы в этом поддереве был хотя бы один красный узел, затем удаляем нужный элемент, как в обычном бинарном дереве поиска, и запускаем алгоритм починки дерева от удаленной вершины
4. Свертки реализованы за счет того, что сначала обходим левое или правое поддерево (в зависимости от свертки).
5. Equal? реализован через проверки равенства get_first, с последующей проверкой следующих минимальных элементов в дереве без текущего минимального
### Property-based тесты
Проверяются следующие свойства:
1. Свойства моноида.
2. Корректная реализация протокола Collectable.
3. Корректное получение минимального элемента RbSet.
4. Двойная вставка элементе не порождает дубликат.
## Вывод
В ходе работы реализовано полиморфное неизменяемое множество на лево‑наклонном красно‑чёрном дереве: вставка/удаление, фильтрация, отображение, свёртки, свойства моноида и интеграция с Collectable/Enum. Через unit‑ и property‑based тесты проверены корректность базовых операций, эквивалентность множеств и законы моноида. Выполнение данной лабораторной работы показало, что функциональный стиль Elixir позволяет компактно и эффективно поддерживать сбалансированную структуру данных, а протоколы (Comparable, Monoid, Collectable) упрощают полиморфизм и совместимость с экосистемой.